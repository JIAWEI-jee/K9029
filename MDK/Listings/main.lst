C51 COMPILER V9.56.0.0   MAIN                                                              09/07/2020 10:03:37 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\output\main.obj
COMPILER INVOKED BY: C:\program_list\keil\C51\BIN\C51.EXE ..\source\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(..\sour
                    -ce;..\HAEDWARE\Flash;..\HAEDWARE\DELAY;..\HAEDWARE\HT1621B;..\HAEDWARE\Uart;..\HAEDWARE\Key;..\HAEDWARE\Timer;..\HAEDWAR
                    -E\Pwm;..\HAEDWARE\ADC;..\HAEDWARE\WDT;..\HAEDWARE\PID) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\ou
                    -tput\main.obj)

line level    source

   1          #define ALLOCATE_EXTERN
   2          #include "HC89F303.h"
   3          #include "intrins.h"//nop
   4          #include "uart.h"
   5          #include "delay.h"
   6          #include "key.h"
   7          #include "flash.h"
   8          #include "timer.h"
   9          #include "pwm.h"
  10          #include "lcd_display.h"
  11          #include "adc.h"
  12          #include "wdt.h"
  13          #include "PID.h"
  14          
  15          #define SKU 9029
  16          #define SOFT_VER "1.00.00"
  17          
  18          u16 adc_cnt = 0;
  19          u8  first_heat_std = 0,fault_std = 0;
  20          
  21          void Set_Temp ( u8 gap );
  22          void Protect ( void );
  23          void Error ( void );
  24          
  25          void device_init ( void )
  26          {
  27   1        /************************************系统初始化****************************************/
  28   1        // CLKSWR = 0x51;           //选择内部高频RC为系统时钟，内部高频RC 2分频，Fosc=16MHz
  29   1        CLKSWR = 0x53;  //8分频 32/8 = 4M
  30   1        CLKDIV = 0x01;            //Fosc 1分频得到Fcpu，Fcpu=16MHz
  31   1        P0M2 = 0x10;            //P02设置为非施密特数字输入
  32   1      }
  33          
  34          
  35          static void key_handle ( void )
  36          {
  37   1        u8 key_val = 0;
  38   1        if ( fault_std == 0 )
  39   1        {
  40   2          key_val = key_scan();
  41   2        }
  42   1        else
  43   1        {
  44   2          key_val = 0;
  45   2        }
  46   1        if ( ( key_val == KEY_1_PRES ) && ( calibration_std == 0 ) )
  47   1        {
  48   2      
  49   2          if ( get_device_state() == ON )
  50   2          {
  51   3      
  52   3            set_device_state ( OFF );
C51 COMPILER V9.56.0.0   MAIN                                                              09/07/2020 10:03:37 PAGE 2   

  53   3            ht1621_all_clear();
  54   3            set_pwm ( 0 );
  55   3          }
  56   2          else
  57   2          {
  58   3            set_device_state ( ON );
  59   3            set_time_sec();
  60   3      
  61   3            first_heat_std = 1;
  62   3            set_correct_time ( flash_info.gap );
  63   3            Set_Temp ( flash_info.gap );
  64   3            lcd_display_gap ( flash_info.gap );
  65   3            lcd_display_time ( flash_info.timer );
  66   3      
  67   3          }
  68   2        }
  69   1        else if ( get_device_state() == ON )
  70   1        {
  71   2      
  72   2      
  73   2      
  74   2          if ( key_val == KEY_2_PRES ) //档位
  75   2          {
  76   3      
  77   3      
  78   3            if ( flash_info.gap < GAP_9 )
  79   3            {
  80   4              flash_info.gap++;
  81   4      
  82   4            }
  83   3            else
  84   3            {
  85   4              flash_info.gap = GAP_1;
  86   4            }
  87   3            if ( flash_info.gap > GAP_3 )
  88   3            {
  89   4              if ( flash_info.timer == TIMER_ON )
  90   4              {
  91   5                On_stay = 2;
  92   5              }
  93   4              else if ( flash_info.timer > TIMER_2H )
  94   4              {
  95   5                Gap_protect_std = 2;
  96   5              }
  97   4            }
  98   3      
  99   3            first_heat_std = 1;
 100   3            set_correct_time ( flash_info.gap );
 101   3            Set_Temp ( flash_info.gap );
 102   3            lcd_display_gap ( flash_info.gap );
 103   3            //set_time_sec();
 104   3            flah_save_data();
 105   3          }
 106   2          else if ( key_val == KEY_3_PRES ) //定时
 107   2          {
 108   3      
 109   3            if ( flash_info.timer < 0x05 )
 110   3            {
 111   4              flash_info.timer++;
 112   4            }
 113   3            else
 114   3            {
C51 COMPILER V9.56.0.0   MAIN                                                              09/07/2020 10:03:37 PAGE 3   

 115   4              flash_info.timer = TIMER_ON;
 116   4            }
 117   3      
 118   3      //      KEY_printf ( "timer:%d \r\n", ( u16 ) flash_info.timer );
 119   3            lcd_display_time ( flash_info.timer );
 120   3            set_time_sec();
 121   3            flah_save_data();
 122   3          }
 123   2        }
 124   1      }
 125          
 126          
 127          u16 calibration_temperature ( u16 temper )
 128          {
 129   1        u8 temp1 = 0;
 130   1        if ( ( usart_rx_flag == 2 ) && ( calibration_std == 1 ) )
 131   1        {
 132   2          temp1 = ( u8 ) temper;
 133   2          usart_rx_flag = 0;
 134   2          flash_info.correct_std = 1;
 135   2      
 136   2          if ( temper_val > 15 )
 137   2          {
 138   3            if ( temper_val > temp1 )
 139   3            {
 140   4              flash_info.correct_value = temper_val - temp1;
 141   4              flash_info.correct_sign = 1; //为正公差
 142   4            }
 143   3            else
 144   3            {
 145   4              flash_info.correct_value = temp1 - temper_val;
 146   4      
 147   4              hal_uart_putchar ( flash_info.correct_value );
 148   4              flash_info.correct_sign = 2; //为负公差
 149   4            }
 150   3            if ( ( flash_info.correct_value < 2 ) || ( flash_info.correct_value > 20 ) )
 151   3            {
 152   4              flash_info.correct_value = 0;
 153   4              flash_info.correct_sign = 0;
 154   4            }
 155   3            flah_save_data();
 156   3            producte_send_cmd ( 0x02, 0x02 );
 157   3          }
 158   2        }
 159   1        if ( flash_info.correct_sign == 1 )
 160   1        {
 161   2          return ( ( u16 ) ( temper = temper + flash_info.correct_value ) );
 162   2        }
 163   1        else if ( flash_info.correct_sign == 2 )
 164   1        {
 165   2          return ( ( u16 ) ( temper = temper - flash_info.correct_value ) );
 166   2        }
 167   1        return ( ( u16 ) temper );
 168   1      
 169   1      }
 170          
 171          
 172          
 173          u16 temp_calc ( u16 uR510,u16 uRw )
 174          {
 175   1        u8 i = 0;
 176   1        u8 basi_tmp = 50;
C51 COMPILER V9.56.0.0   MAIN                                                              09/07/2020 10:03:37 PAGE 4   

 177   1        u8 k = 10;
 178   1        float u1 = 0;
 179   1      
 180   1        if ( ( uR510 < 50 ) || ( uR510 > uRw ) )
 181   1        {
 182   2          return 0xff;
 183   2        }
 184   1      
 185   1      
 186   1        u1 = (  ( ( float ) uRw /1000 ) - ( ( float ) uR510/1000 ) ) / ( ( ( float ) uR510/1000 ) /510 );
 187   1        if ( u1 < 0 )
 188   1        {
 189   2          return 0xff;
 190   2        }
 191   1        //gm_printf ( "R = %f  \r\n",u1 );
 192   1        u1 = u1 / Length;
 193   1        if ( u1 < 73 )
 194   1        {
 195   2          return 0;
 196   2        }
 197   1        // gm_printf("average R = %f \r\n",u1);
 198   1        u1 = u1 / Temperature_Value;
 199   1        //gm_printf("cmp = %f \r\n",u1);
 200   1        if ( u1*Temperature_Value > Temperature_Value )
 201   1        {
 202   2          while ( 1 )
 203   2          {
 204   3            u1 = u1 / ( 1 + 0.0048 );
 205   3            i++;
 206   3            if ( u1 <= 1 )
 207   3            {
 208   4              break;
 209   4            }
 210   3      
 211   3          }
 212   2          // gm_printf("basi_tmp_u1 = %d \r\n",basi_tmp);
 213   2          basi_tmp = basi_tmp + i;
 214   2          //gm_printf("basi_tmp_u1f = %d \r\n",basi_tmp);
 215   2        }
 216   1        else
 217   1        {
 218   2          while ( 1 )
 219   2          {
 220   3            u1 = u1 / ( 1 - 0.0048 );
 221   3            i++;
 222   3            if ( u1 >= 1 )
 223   3            {
 224   4              break;
 225   4            }
 226   3      
 227   3      
 228   3          }
 229   2          // gm_printf("i = %d \r\n",i);
 230   2          basi_tmp = basi_tmp - i;
 231   2        }
 232   1        //gm_printf("basi_tmpF:%d \r\n",basi_tmp);
 233   1      
 234   1        return ( basi_tmp );
 235   1      }
 236          
 237          
 238          
C51 COMPILER V9.56.0.0   MAIN                                                              09/07/2020 10:03:37 PAGE 5   

 239          void temperature_handle ( void )
 240          {
 241   1        u16 temp = 0;
 242   1        u16 adc_val1 = 0,adc_val3 = 0;
 243   1        static u8 error_std = 0;
 244   1        adc_cnt++;
 245   1      
 246   1        if ( adc_cnt > 10000 )
 247   1        {
 248   2          adc_cnt = 0;
 249   2          get_voltage ( &adc_val1,&adc_val3 );
 250   2      
 251   2          //  KEY_printf ( "adv1 = %d adv3 =%d \r\n",adc_val1,adc_val3 );  //pjw set
 252   2          temp = temp_calc ( adc_val1, adc_val3 );
 253   2          //KEY_printf ( "temp val:%d \r\n",temp );
 254   2          temp =  calibration_temperature ( temp );
 255   2          KEY_printf ( "%d \r\n",temp );
 256   2      
 257   2          if ( adc_val1 >50 )
 258   2          {
 259   3            if ( get_device_state() == ON )
 260   3            {
 261   4              if ( first_heat_std == 1 )
 262   4              {
 263   5                first_heat_std = 0;
 264   5                if ( temp > 50 )
 265   5                {
 266   6                  Heat_start_std = 2;
 267   6                  Open_Heat_Value = corrected_value_GAP_6_temp  ;
 268   6                }
 269   5                else
 270   5                {
 271   6                  Heat_start_std = 2;
 272   6                  one_heat = 1;
 273   6                  Open_Heat_Value = corrected_value_warm_temp ;
 274   6                }
 275   5              }
 276   4      
 277   4              if ( one_heat == 0 )
 278   4              {
 279   5                spid.iCurVal = temp*10;
 280   5                PID_Operation ();
 281   5              }
 282   4              else if ( one_heat == 1 )
 283   4              {
 284   5                Controll_Heat ( One_Heat_Temp, temp );
 285   5              }
 286   4              lcd_display_time ( flash_info.timer );
 287   4              lcd_display_gap ( flash_info.gap );
 288   4      
 289   4            }
 290   3            else
 291   3            {
 292   4              if ( calibration_std == 1 )
 293   4              {
 294   5                set_pwm ( 0 );
 295   5                ht1621_all_clear();
 296   5                lcd_display_gap ( flash_info.gap );
 297   5                cali_display_std = 1;
 298   5              }
 299   4              else
 300   4              {
C51 COMPILER V9.56.0.0   MAIN                                                              09/07/2020 10:03:37 PAGE 6   

 301   5                set_pwm ( 0 );
 302   5                ht1621_send_cmd ( LCD_OFF );
 303   5                cali_display_std = 0;
 304   5              }
 305   4            }
 306   3            fault_std = 0;
 307   3          }
 308   2          else
 309   2          {
 310   3            calibration_std = 0;
 311   3            cali_display_std = 0;
 312   3            ht1621_all_clear();
 313   3            set_pwm ( 0 );
 314   3            error_std = Error_STD;
 315   3            lcd_display_gap ( error_std );
 316   3            fault_std = 1;
 317   3          }
 318   2      
 319   2        }
 320   1      
 321   1      
 322   1      }
 323          
 324          
 325          
 326          
 327          void main ( void )
 328          {
 329   1        device_init();
 330   1      
 331   1        uart_init();
 332   1        adc_init();
 333   1        EA = 1;//开启总中断
 334   1        key_init();
 335   1        time0_init();
 336   1        flash_init();
 337   1        pwm_init ( 200 );
 338   1        init_lcd_ht1621b();
 339   1        delay_ms ( 800 );
 340   1        wdt_init ( 2 );
 341   1        PID_Init();
 342   1        set_pwm ( 0 );
 343   1        gm_printf ( "\r\n==================================\r\n" );
 344   1        gm_printf ( "sku:K%d \r\n", ( u16 ) SKU );
 345   1        gm_printf ( "soft version:%s \r\n",SOFT_VER );
 346   1        gm_printf ( "gap %d \r\n", ( u16 ) flash_info.gap );      //挡位
 347   1        gm_printf ( "timer %d \r\n", ( u16 ) flash_info.timer );  // 时间长度
 348   1        gm_printf ( "==================================\r\n" );
 349   1      
 350   1        while ( 1 )
 351   1        {
 352   2          key_handle();
 353   2          temperature_handle();
 354   2          // Protect();
 355   2      
 356   2          clear_wdt();
 357   2      
 358   2        }
 359   1      }
 360          
 361          
 362          
C51 COMPILER V9.56.0.0   MAIN                                                              09/07/2020 10:03:37 PAGE 7   

 363          void Set_Temp ( u8 gap )
 364          {
 365   1      
 366   1        switch ( gap )
 367   1        {
 368   2          case GAP_WARM:
 369   2            spid.iSetVal = GAP_WARM_temp*10;
 370   2            break;
 371   2          case GAP_1:
 372   2            spid.iSetVal = GAP_1_temp*10;
 373   2            break;
 374   2          case GAP_2:
 375   2            spid.iSetVal = GAP_2_temp*10;
 376   2            break;
 377   2          case GAP_3:
 378   2            spid.iSetVal = GAP_3_temp*10;
 379   2            break;
 380   2          case GAP_4:
 381   2            spid.iSetVal = GAP_4_temp*10;
 382   2            break;
 383   2          case GAP_5:
 384   2            spid.iSetVal = GAP_5_temp*10;
 385   2            break;
 386   2          case GAP_6:
 387   2            spid.iSetVal = GAP_6_temp*10;
 388   2            break;
 389   2          case GAP_7:
 390   2            spid.iSetVal = GAP_7_temp*10;
 391   2            break;
 392   2          case GAP_8:
 393   2            spid.iSetVal = GAP_8_temp*10;
 394   2            break;
 395   2          case GAP_9:
 396   2            spid.iSetVal = GAP_9_temp*10;
 397   2            break;
 398   2        }
 399   1      }
 400          
 401          
 402          
 403          
 404          void Protect ( void )
 405          {
 406   1        if ( over_rang_time_std == 1 )
 407   1        {
 408   2          if ( flash_info.gap > GAP_3 )
 409   2          {
 410   3            flash_info.gap = GAP_3;
 411   3            lcd_display_gap ( flash_info.gap );
 412   3            flah_save_data();
 413   3            over_rang_time_std = 0;
 414   3          }
 415   2        }
 416   1      }
 417          
 418          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1657    ----
   CONSTANT SIZE    =    142    ----
   XDATA SIZE       =      5      20
C51 COMPILER V9.56.0.0   MAIN                                                              09/07/2020 10:03:37 PAGE 8   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
