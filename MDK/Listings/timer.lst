C51 COMPILER V9.56.0.0   TIMER                                                             09/04/2020 11:37:41 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\output\timer.obj
COMPILER INVOKED BY: C:\program_list\keil\C51\BIN\C51.EXE ..\HAEDWARE\Timer\timer.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDI
                    -R(..\source;..\HAEDWARE\Flash;..\HAEDWARE\DELAY;..\HAEDWARE\HT1621B;..\HAEDWARE\Uart;..\HAEDWARE\Key;..\HAEDWARE\Timer;.
                    -.\HAEDWARE\Pwm;..\HAEDWARE\ADC;..\HAEDWARE\WDT;..\HAEDWARE\PID) DEBUG OBJECTEXTEND PRINT(.\Listings\timer.lst) TABS(2) O
                    -BJECT(.\output\timer.obj)

line level    source

   1          #include "timer.h"
   2          #include "flash.h"
   3          #include "uart.h"
   4          #include "lcd_display.h"
   5          #include "PID.h"
   6          #include "pwm.h"
   7          #include "key.h"
   8          //----------------time---------------
   9          u8 time_cnt = 0;
  10          u16 time_sec = 0;
  11          u16 cnt_heat_time = 0;
  12          u8 over_rang_time_std = 0;
  13          u8 Gap_protect_std = 0 ;
  14          u8 On_stay = 0;
  15          u8  Open_Heat_Value = 0;
  16          u8 Heat_start_std = 0;
  17          u16 time_heat = 0;
  18          u16 temp_time = 0 ;
  19          u16 correct_time = 0;
  20          u8 one_heat = 0;
  21          u16 exti_cail_cnt = 0;
  22          u16 pwm_jishu = 0;
  23          
  24          void Controll_Heat ( u16 temp_set,u16 temp_now )
  25          {
  26   1      //KEY_printf ( "temp_set val:%d \r\n",temp_set );
  27   1        if ( temp_now >  temp_set   )
  28   1        {
  29   2          //  KEY_printf ( "close_heat \r\n");
  30   2          set_pwm ( 0 ); // 关闭加热丝
  31   2        }
  32   1        else if ( temp_now < ( temp_set - Open_Heat_Value ) )
  33   1        {
  34   2          //KEY_printf ( "open_heat \r\n");
  35   2          set_pwm ( 10 ); //打开加热丝
  36   2        }
  37   1      }
  38          
  39          
  40          
  41          
  42          void Heat_Operation ( u16 temp )
  43          {
  44   1        if ( one_heat == 0 )
  45   1        {
  46   2          pwm_jishu++;
  47   2          if ( temp > pwm_jishu )
  48   2          {
  49   3            set_pwm ( 10 );
  50   3      
  51   3          }
  52   2          else
C51 COMPILER V9.56.0.0   TIMER                                                             09/04/2020 11:37:41 PAGE 2   

  53   2          {
  54   3            set_pwm ( 0 );
  55   3      
  56   3          }
  57   2          if ( pwm_jishu == pwm_count )
  58   2          {
  59   3            pwm_jishu =0;
  60   3          }
  61   2        }
  62   1      }
  63          
  64          
  65          void set_time_sec_val ( u16 sec )
  66          {
  67   1        time_sec = sec;
  68   1        time_cnt = 0;
  69   1        gm_printf ( "set time second:%d\r\n",sec );
  70   1      }
  71          void set_correct_time ( u8 gap )
  72          {
  73   1      
  74   1        switch ( gap )
  75   1        {
  76   2          case GAP_WARM:
  77   2            correct_time = corrected_time_warm_temp;
  78   2            break;
  79   2          case GAP_1:
  80   2            correct_time = corrected_time_GAP_1_temp;
  81   2            break;
  82   2          case GAP_2:
  83   2            correct_time = corrected_time_GAP_2_temp;
  84   2            break;
  85   2          case GAP_3:
  86   2            correct_time = corrected_time_GAP_3_temp;
  87   2            break;
  88   2          case GAP_4:
  89   2            correct_time = corrected_time_GAP_4_temp;
  90   2            break;
  91   2          case GAP_5:
  92   2            correct_time = corrected_time_GAP_5_temp;
  93   2            break;
  94   2          case GAP_6:
  95   2            correct_time = corrected_time_GAP_6_temp;
  96   2            break;
  97   2          case GAP_7:
  98   2            correct_time = corrected_time_GAP_7_temp;
  99   2            break;
 100   2          case GAP_8:
 101   2            correct_time = corrected_time_GAP_8_temp;
 102   2            break;
 103   2          case GAP_9:
 104   2            correct_time = corrected_time_GAP_9_temp;
 105   2            break;
 106   2      
 107   2        }
 108   1      }
 109          static void set_correct_Value ( void )
 110          {
 111   1        switch ( flash_info.gap )
 112   1        {
 113   2          case GAP_WARM:
 114   2            Open_Heat_Value = corrected_value_warm_temp;
C51 COMPILER V9.56.0.0   TIMER                                                             09/04/2020 11:37:41 PAGE 3   

 115   2            break;
 116   2          case GAP_1:
 117   2            Open_Heat_Value = corrected_value_GAP_1_temp;
 118   2            break;
 119   2          case GAP_2:
 120   2            Open_Heat_Value = corrected_value_GAP_2_temp;
 121   2            break;
 122   2          case GAP_3:
 123   2            Open_Heat_Value = corrected_value_GAP_3_temp;
 124   2            break;
 125   2          case GAP_4:
 126   2            Open_Heat_Value = corrected_value_GAP_4_temp;
 127   2            break;
 128   2          case GAP_5:
 129   2            Open_Heat_Value = corrected_value_GAP_5_temp;
 130   2            break;
 131   2          case GAP_6:
 132   2            Open_Heat_Value = corrected_value_GAP_6_temp;
 133   2            break;
 134   2          case GAP_7:
 135   2            Open_Heat_Value = corrected_value_GAP_7_temp;
 136   2            break;
 137   2          case GAP_8:
 138   2            Open_Heat_Value = corrected_value_GAP_8_temp;
 139   2            break;
 140   2          case GAP_9:
 141   2            Open_Heat_Value = corrected_value_GAP_9_temp;
 142   2            break;
 143   2      
 144   2      
 145   2        }
 146   1      
 147   1      }
 148          static void set_heat_val ( void )
 149          {
 150   1        if ( Heat_start_std == 2 )
 151   1        {
 152   2      
 153   2      
 154   2          if ( ++time_heat > correct_time )
 155   2          {
 156   3            KEY_printf ( "exchange_heat_value \r\n" );
 157   3            Heat_start_std = 0;
 158   3            time_heat = 0;
 159   3            one_heat = 0;
 160   3      
 161   3            set_correct_Value (  );
 162   3          }
 163   2        }
 164   1      }
 165          
 166          void set_time_sec ( void )
 167          {
 168   1        time_cnt = 0;
 169   1        if ( flash_info.timer == TIMER_ON )
 170   1        {
 171   2          time_sec = 0;
 172   2          cnt_heat_time = 0;
 173   2          temp_time = 0;
 174   2        }
 175   1        else if ( flash_info.timer == TIMER_0_5H )
 176   1        {
C51 COMPILER V9.56.0.0   TIMER                                                             09/04/2020 11:37:41 PAGE 4   

 177   2          time_sec = 30*60;
 178   2          cnt_heat_time = 0;
 179   2          temp_time = 0;
 180   2        }
 181   1        else if ( flash_info.timer == TIMER_1H )
 182   1        {
 183   2          time_sec = 60*60;
 184   2          cnt_heat_time = 0;
 185   2          temp_time = 0;
 186   2        }
 187   1        else if ( flash_info.timer == TIMER_2H )
 188   1        {
 189   2          time_sec = 2*60*60;
 190   2          cnt_heat_time = 0;
 191   2          temp_time = 0;
 192   2        }
 193   1        else if ( flash_info.timer == TIMER_4H )
 194   1        {
 195   2          time_sec = 4*60*60;
 196   2          cnt_heat_time = 0;
 197   2          temp_time = 0;
 198   2        }
 199   1        else if ( flash_info.timer == TIMER_8H )
 200   1        {
 201   2          time_sec = 8*60*60;
 202   2          cnt_heat_time = 0;
 203   2          temp_time = 0;
 204   2        }
 205   1        gm_printf ( "time second:%d \r\n",time_sec );
 206   1      }
 207          
 208          
 209          void time0_init ( void )
 210          {
 211   1        /**********************************TIM0配置初始化**************************************/
 212   1        TCON1 = 0x00;           //Tx0定时器时钟为Fosc/12
 213   1        TMOD = 0x00;            //16位重装载定时器/计数器
 214   1        //定时10ms
 215   1        //反推初值  = 65536 - ((10/1000) / (1/(Fosc / Timer分频系数)))
 216   1        //        = 65536 - ((10/1000) / (1/(16000000 / 12)))
 217   1        //      = 65536 - 13333
 218   1        //      = 0xCBEC
 219   1        // TH0 = 0xCB;
 220   1        // TL0 = 0xEB;              //T0定时时间10ms  16MHZ
 221   1        TH0 = 0xF2;
 222   1        TL0 = 0xFB;             //T0定时时间10ms  4MHZ
 223   1        TF0 = 0;//清除中断标志
 224   1        ET0 = 1;//打开T0中断
 225   1        TR0 = 1;//使能T0
 226   1        EA = 1;               //打开总中断
 227   1      }
 228          
 229          
 230          
 231          //10ms
 232          void TIMER0_Rpt ( void ) interrupt TIMER0_VECTOR
 233          {
 234   1        if ( get_device_state() == ON ) //flash_info.timer != TIMER_ON &&
 235   1        {
 236   2          time_cnt++;
 237   2          if ( time_cnt >= 100 )
 238   2          {
C51 COMPILER V9.56.0.0   TIMER                                                             09/04/2020 11:37:41 PAGE 5   

 239   3            set_heat_val();
 240   3      
 241   3            if ( On_stay == 2 )  // stay on 模式下进行保护
 242   3            {
 243   4              cnt_heat_time++;
 244   4              if ( cnt_heat_time > overrang_time )
 245   4              {
 246   5                On_stay = 0;
 247   5                cnt_heat_time = 0;
 248   5                over_rang_time_std = 1;
 249   5                //gm_printf ( "On_stay_overrang \r\n" );
 250   5              }
 251   4      
 252   4            }
 253   3            if ( time_sec > 0 )
 254   3            {
 255   4      
 256   4              time_sec--;
 257   4              if ( Gap_protect_std == 2 )
 258   4              {
 259   5      
 260   5                cnt_heat_time++;
 261   5      
 262   5      
 263   5                if ( cnt_heat_time > overrang_time )
 264   5                {
 265   6                  over_rang_time_std = 1;
 266   6                  Gap_protect_std = 0;
 267   6                  cnt_heat_time = 0;
 268   6                  gm_printf ( "protect \r\n" );
 269   6                }
 270   5              }
 271   4            }
 272   3            else
 273   3            {
 274   4              if ( flash_info.timer != TIMER_ON )
 275   4              {
 276   5                set_device_state ( OFF );
 277   5                time_sec = 0;
 278   5                cnt_heat_time = 0;
 279   5                Gap_protect_std = 0;
 280   5                On_stay = 0;
 281   5                ht1621_all_clear(); //定时时间到
 282   5                gm_printf ( "time off \r\n" );
 283   5              }
 284   4            }
 285   3            //gm_printf("time_sec=%d \r\n",time_sec);
 286   3            time_cnt = 0;
 287   3          }
 288   2          Heat_Operation ( spid.iPriVal );
 289   2        }
 290   1        else if ( calibration_std == 1 )
 291   1        {
 292   2          if ( ++exti_cail_cnt > cali_time )
 293   2          {
 294   3            calibration_std = 0;
 295   3            exti_cail_cnt = 0;
 296   3          }
 297   2        }
 298   1      }
 299          
 300          void time_Print ( void )
C51 COMPILER V9.56.0.0   TIMER                                                             09/04/2020 11:37:41 PAGE 6   

 301          {
 302   1        switch ( ++temp_time )
 303   1        {
 304   2          case H_0_5:
 305   2            gm_printf ( "time_to_0.5H  time_sec=%d \r\n",time_sec );
 306   2            temp_time = 0;
 307   2            break;
 308   2          case H_1_0:
 309   2            gm_printf ( "time_to_1H  time_sec=%d \r\n",time_sec );
 310   2            temp_time = 0;
 311   2            break;
 312   2          case H_2_0:
 313   2            gm_printf ( "time_to_2H  time_sec=%d \r\n",time_sec );
 314   2            temp_time = 0;
 315   2            break;
 316   2          case H_4_0:
 317   2            gm_printf ( "time_to_4H  time_sec=%d \r\n",time_sec );
 318   2            temp_time = 0;
 319   2            break;
 320   2          case H_8_0:
 321   2            gm_printf ( "time_to_8H  time_sec=%d \r\n",time_sec );
 322   2            temp_time = 0;
 323   2            break;
 324   2        }
 325   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1004    ----
   CONSTANT SIZE    =    222    ----
   XDATA SIZE       =     21       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
